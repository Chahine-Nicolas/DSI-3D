import pandas as pd
from sklearn.model_selection import train_test_split
import json
import math
from extern.pcdet.datasets.kitti360.kitti360_dataset import load_poses_from_txt, load_timestamps
import numpy as np
class DSIDatasets:
    def __init__(self,dataset_cfg=None):
        print("ini")
        self.dataset_cfg = dataset_cfg
        self.list_gt = []
        self.dsi_infos_gt = {}
        self.labeltype = 'docid'
        if self.dataset_cfg is not None :    
            self.labeltype =  self.dataset_cfg['LABEL_TYPE']



        # eval_seq = 0
        # kitti_dir = "/lustre/fsn1/worksf/projects/rech/dki/ujo91el/datas/datasets/", "/lustre/fsn1/worksf/projects/rech/dki/ujo91el/datas/datasets/"
        # eval_seq = '%02d' % eval_seq
        # sequence_path = kitti_dir + 'sequences/' + eval_seq + '/'
        # _, positions_database2 = load_poses_from_txt(sequence_path + 'poses.txt'


        # self.positions_database = positions_database
        # min_bbox = np.min(self.positions_database,0) 
        # self.positions_database = self.positions_database - min_bbox
        self.gpsround = 100
        
    def load_gt_infos(self,root_path) :
        self.dsi_infos_gt = json.load(open(root_path /"matching.json", "r"))        

<<<<<<< HEAD
    
    ###########################################################################
    ###########################################################################
    """
    
=======
    def get_hierarchical_label(self,label_id) :
        return self.hierarchical_label[str(int(label_id))]
        
>>>>>>> ce94d9378e0feaf1091084d48846ea95dca0873b
    def label2gps(self,label_id) :
        label_id_gps = self.positions_database[int(label_id)]
        xx = round(label_id_gps[0]*self.gpsround)
        yy = round(label_id_gps[1]*self.gpsround)
        xx_str = f'{xx:05}'
        yy_str = f'{yy:05}'
        res_str = ''.join(x + y for x, y in zip(xx_str, yy_str))
        res_str += xx_str[len(yy_str):] + yy_str[len(xx_str):]
        #import pdb; pdb.set_trace()                    
        return res_str

    def gps2position(self,res_str) :
        xx_str = res_str[::2]
        yy_str = res_str[1::2]
        pos = [float(xx_str)/self.gpsround,float(yy_str)/self.gpsround,0]
        return pos
        # if gpsstr.isnumeric() and len(gpsstr) == 8:
        #     return [float(gpsstr[0:4])/self.gpsround,float(gpsstr[4:8])/self.gpsround,0]
        # else :
        #     return [0,0,0]
        
    
    def get_label_from_path(self,ss) :
        return ss.split('/')[-1][:-4]

    def get_gt_label_from_truth(self,tt,pos=0) :
        #n = list(tt.values())[0][0][pos]
        return tt[0][0]
        #return f'{n:06}'
    
    def get_gt_label(self,index,pos=0) :
        #import pdb; pdb.set_trace()
        return self.get_gt_label_from_truth(self.dsi_infos_gt[self.get_id(index)],pos) 


    def get_id(self,index): #get label for 4541 bin
        return '%06d' % int(self.get_label_from_path(self.kitti_infos[index]) )

    
    def get_label(self,index): #get label for 4541 bin
        ii = self.get_id(index)
        if self.training or self.do_self_eval  :
            if self.labeltype == 'gps' :
                return self.label2gps(ii)
            elif self.labeltype == 'hierarchical' :
                return self.get_hierarchical_label(ii)
            else :
                return ii
        else :
            return self.get_gt_label(index) 
            # if self.labeltype :
            #     return self.label2gps(self.get_gt_label(index))
            # else :
            #     return self.get_gt_label(index) 

        
    def filter_dataset(self,nbe) :
        kitti_infos_filtered_train = []
        kitti_infos_filtered_eval = []

        #print("len(self.kitti_infos) ", len(self.kitti_infos))
        #import pdb; pdb.set_trace()
        self.kitti_infos = []
        self.include_kitti_data()

        #print(" self.dsi_infos_gt.keys() ", self.dsi_infos_gt.keys())
        for ii in range(len(self.kitti_infos)) :
            pth = self.kitti_infos[ii] # 'velodyne/003539.bin'
            iid = '%06d' % int(self.get_label_from_path(pth)) # '003539'
            
            if iid in self.dsi_infos_gt : # '003327': [[2383, 2382, 2384
                kitti_infos_filtered_eval.append(self.kitti_infos[ii]) # ['velodyne/003644.bin', 'velodyne/003405.bin', 
                #gt_lab = self.get_gt_label_from_truth(self.dsi_infos_gt[iid]) 
                gt_lab = self.dsi_infos_gt[iid][0][0] # '000418'

                self.list_gt.append(gt_lab) # [700, 2453, 2454, 521, 938, ..
                
            if len(kitti_infos_filtered_eval) >= nbe :
                break
        #import pdb; pdb.set_trace() 
        for ii in range(len(self.kitti_infos)) : # len(32)
            pth = self.kitti_infos[ii]
            iid = '%06d' % int(self.get_label_from_path(pth)) # 3539
            if iid in self.list_gt or (not self.train_only_revisited)  :
                 kitti_infos_filtered_train.append(self.kitti_infos[ii])

        if self.training : # True
            nbe_fe=math.floor(len(kitti_infos_filtered_train)/16)*16 # 32
            self.kitti_infos = kitti_infos_filtered_train[:nbe_fe] # ['velodyne/000651.bin', 'velodyne/002346.bin', ..
        else :
            nbe_fe=math.floor(len(kitti_infos_filtered_eval)/16)*16 
            self.kitti_infos = kitti_infos_filtered_eval[:nbe_fe]   
        #import pdb; pdb.set_trace()  
        # if False :
        #     vv=next(iter(self.dsi_infos_gt))

    def get_dict_dsi(self, index):            
        # End load proximus
        input_dict = {}
        input_dict['id'] = self.get_id(index) #self.eval_seq_str + self.get_id(index) # multi
        if self.gpslabel:
             input_dict['labels'] = self.get_label(index) #self.eval_seq_str + '%06d' % int(self.get_label(index)) # multi
             if not self.get_label(index)[:].isdigit():
                 import pdb; pdb.set_trace()
        else:
            input_dict['labels'] = '%06d' % int(self.get_label(index)) #self.eval_seq_str + '%06d' % int(self.get_label(index)) # multi
        input_dict['gps'] = self.label2gps(input_dict['id'][2:])
        if self.training or self.do_self_eval  :
            input_dict['gt'] = '-1'
        else :
            input_dict['gt'] = self.get_gt_label(index)  #self.eval_seq_str + self.get_gt_label(index) 
        #import pdb; pdb.set_trace()
        return input_dict