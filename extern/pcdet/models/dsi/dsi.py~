from .dsi_template import DSI3DTemplate



class DSI(DSI3DTemplate):
    def __init__(self, model_cfg, num_class, dataset, logger):
        super().__init__(model_cfg=model_cfg, num_class=num_class, dataset=dataset, logger=logger)
        self.module_list = self.build_networks()

        mlps = self.model_cfg.CONFIG.MLPS.copy()
        input_channels=self.dataset.point_feature_encoder.num_point_features
        channel_out = 0
        for idx in range(mlps.__len__()):
            mlps[idx] = [input_channels] + mlps[idx]
            channel_out += mlps[idx][-1]
            
        self.cls_conv = self.make_fc_layers(
            fc_cfg=self.model_cfg.CONFIG.CLS_FC,
            input_channels=channel_out,
            output_channels=num_class,
            linear=True
        )
        
    def forward(self, batch_dict):
        for cur_module in self.module_list:
            batch_dict = cur_module(batch_dict)

        all_voxel_features, all_voxel_coords = batch_dict['voxel_features'], batch_dict['voxel_coords']
        index = batch_dict['index']
        vote_cls_preds = self.cls_conv(vote_features)
        print(index)

        ret_dict = {
            'vote_cls_preds': vote_cls_preds,
            'batch_size': batch_dict['batch_size']
        }

        self.forward_ret_dict = ret_dict
        if self.training:
            loss, tb_dict, disp_dict = self.get_training_loss()

            ret_dict = {
                'loss': loss
            }
            return ret_dict, tb_dict, disp_dict
        else:
            pred_dicts, recall_dicts = self.post_processing(batch_dict)
            return pred_dicts, recall_dicts

    def get_training_loss(self):
        disp_dict = {}

        ##loss_rpn, tb_dict = self.backbone_3d.get_loss()
        tb_dict = disp_dict;
        tb_dict = {
            'loss_rpn': loss_rpn.item(),
            **tb_dict
        }

        ## Cross entropy
        # batch_loss_cls = F.cross_entropy(rcnn_cls, rcnn_cls_labels, reduction='none', ignore_index=-1)
        # cls_valid_mask = (rcnn_cls_labels >= 0).float()
        # rcnn_loss_cls = (batch_loss_cls * cls_valid_mask).sum() / torch.clamp(cls_valid_mask.sum(), min=1.0)

        
        loss = loss_rpn
        return loss, tb_dict, disp_dict
